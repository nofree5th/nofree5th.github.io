---
layout: blog
title: Go语言的类型系统
category: blog
---
《Go语言编程》(许式伟 吕桂华等编著)虽说是国内最先一批出版的关于golang的读物，但是质量实在太差，很多问题流于表面，浅尝则止，不可谓不遗憾。

## 1. 引用与值

若说类型系统是语言的基石，引用与值则是类型的纲领。在C++时代隐约明晰的两个概念，随着更高抽象级别语言的出现（Java/C#)，却显得愈加暧昧难明，以至于达到相争必不知所言的尴尬境地。虽则糊涂，却并不影响语言的正常使用，恰如我不知道我是谁，但我活得很好。

在函数传参或者赋值时，厘清引用与值的意义，是每个程序员的职责所在。其复杂性体现在语法层面的障眼法（语法糖）、语言内置类型的不透明性，以及无限制层次指针与深浅复制相关问题。

实际上放到C++的语境下，了无秘密。本节从C++的视角看各语言语境下引用与值的定位。
###2.1. C++
C++提供了语法层面的“引用”，如：

```C++
int a = 1;
int& refA = a;
```

此时可以将refA看作a的别名，也就是说refA和a除了变量名的区别外，再无其他不同（任何施加在这两者之上的操作都完全等价）。这里C++的实现可以很简单，编译层面把refA看作a即可。函数传参时的引用则可以传入原变量的指针，引用只不过提供了语法层面的便利（访问变量内容时，无需*a，直接refA）。

结论：C++中的赋值、参数传递，除了显示使用&符号表明引用的，其他都是值语义。 什么是值语义？传递时复制原变量的内容（浅复制）。

也就是：

```C++
void foo(int);
void fooPointer(int* );

int a = 42;
foo(a); // 传值无疑

fooPointer(&a); // 这里估计是比较容易混淆的地方，传了a的地址，意味着在函数foo里面可以修改a的值，那么应该叫引用？错，仍然是传值，对于类型int*，这里传参复制了int*类型的指（地址）

struct Person {
    ...
};

void bar(Person);

Person p;
bar(p); // 传值，这里会把p这个结构体的内容复制一份（浅复制），所以当结构体成员较多时，开销是比较大的，可以优化为const Person&，这样转为引用语义就无需复制了（编译器层面传指针实现，只有指针复制的开销）
```

### 1.2. Java

Java号称完全面向对象，所有的“对象类型”可以认为都是C++里面的指针类型，new JavaClass()时虽然看不到指针的痕迹(Java根本木有指针)，当你脑补成C++里面的JavaClass* obj = new JavaClass(...)时（可以认为是Java的底层实现），赋值、传参就阔然开朗了，复制的都是指针，所以传参、赋值的成本都很低，传进去后是可以修改对象指向的内容的——这在Java里面称为**引用**类型。

这里的“引用”和C++的引用是两回事，这里的引用实际上相当于C++的指针。只不过在Java中，所有对象都强制为指针类型，方法中传入对象后，可以修改对象的成员，调用返回后，原对象可以观察到这种改变。

> C++里面的引用是指当调用函数：foo(obj)时，foo函数是有可能改变obj本身（obj为指针类型，传入了指针的指针，从而在函数返回时可以改变obj本身的值），而不仅仅是obj这个指针指向的内容。

考虑到效率，当然不能一个int也是c++的int*，所以Java会有一批内置的简单类型，如int、float、bool等。这些实际上就和C++的对应了，传的都是值。

### 1.3. C#

C#和Java基本差不多，但是C#作为后辈，站在前人的基础上，必然吸收了不少经验总结了不少教训。

C#除了支持int、float、bool这样的值类型，还支持复合类型的值类型，即struct，另一方面继承了Java的“引用”类型（C++的指针类型），并且提供了ref这样的真引用语法。当然类型系统也就相对复杂了些。

## 2. Go的类型系统

### 2.1. Go是什么？

Go就是golang，很现代的一门语言。相信看到这篇文章的读者，都听说过Go的设计原则，诸如“大道至简”、“少即是多”，也听人说过Go在降低程序员心智负担上面殚精竭力。然而，“少”隐藏的细节却带入了迷惑。比如interface到底是如何工作的？slice真的是引用吗？array为什么又是值语义？这也是这篇文章力求说明白的地方。

### 2.2. “引用”的本质？

经过前面一轮的洗脑，想必你更糊涂了，其实很简单，什么东西可以称得上“引用”呢？如果a是b的引用，那么通过对a的修改在某种程度上可以反应在b身上。这个定义可谓感性，还有很多需要明确定义的地方。

其实最开始，只有赋值（传参类似），赋的是“值”，汇编、机器指令级别支持类似MOV的操作，高级语言再扩展一下，就是类似memcpy，复制一块或者N块内存。

那么一块内存是什么？事实上一个变量就是对内存块的抽象。对于那些复杂类型的变量（结构体/类），有着复杂的“内存布局”，可能通过指针指向另一块内存，这样一级串一级，最终枝桠横布。深复制、浅复制在这里找到了他们的渊源。值、引用，在这里缠绵悱恻。

根据变量本身的内存块级别，我们将变量分类如下：

 - 0级，如int32_t，对应一个4字节的内存块，这种变量内部无其他构造，赋值或传参到相同类型变量时，要么复制4字节内存块的内容（值语义），要么把指向4字节内存块的地址传过去（引用语义）。（0级别的类型构成的struct仍然是0级别的）
 - 1级，如struct { int* pointer_to_level2_var }， 这种类型的变量，在0级别的内存块上只有4字节（假设指针即地址占4字节空间），然而通过这个4字节的内容，又指向一块新的内存块，这2个级别上的内存都是可以被修改的。纯粹的值语义，到底是复制0级别的内存（这样或导致新对象和原对象指向同样的1级别内存），还是复制1级别的内存（0级别的比如指向新的1级别，不过1级别的内容完全一致），这是一个问题。实际上这只有结构体的设计者才知道（指针指向的内容是否该变量的内容，可能变量内包括了一个指针，实际上指针指向的内容变量并不关心，那么这个指针就可以当成普通的0级变量）。
 - 2级类似，指针指向的内存块里面还有指针^_^
 
 这样分类后，引用就比较容易定义了，广义的引用可以定义为传参或赋值后，至少有部分内存是相同的（也就是在某个级别上的指针指向同一块内存）。
 
### 2.3. slice是什么？

从目前Go的定义上来看，slice至少是1级别的变量，如下：

```C++
struct slice { // level 0
  int len;
  int cap;
  T* elems; // elems指向level 1
};  // 0级内存大小为int+int+(T*)，1级的内存大小为T（elems指向）
```
 从前面引用的广义定义来看，slice是引用，因为赋值或传参后新的变量可以修改原变量的内容（elems），而len和cap则互相独立，因此slice这个引用如果看成上面的结构体，那么传参和赋值实际上是0级变量的值语义。
 
即slice=0级复制+1级引用

当然slice的定义也可以如下：

```C++
struct slice_struct { // level 1
  int len;
  int cap;
  T* elems; // elems 指向level2
};

struct slice { // level 0
  slice_struct* slice_impl;
}
```

这时，slice=0级复制+1级复制+1级引用
然而0级是否存在或者存在更多这样的级别都是可能却不必要的，因此这里只讨论必要的层级。后同。
 
### 2.4. array呢？

```C++
struct array { // level 0
  T* elems; // elems指向level1
  int len;
  ...
};
```

很明显，array是一个纯粹的值语义，因为array在c++层次至少是1级别的变量，它的赋值或传参由go进行了深度复制。

即array=0级复制+1级复制

看出问题来了吗？效率低下！那么在go没有const修饰的情况下，似乎用array传参的情况应该尽量避免。（如果有const可以修饰，那么go编译器可以优化为传指针。在目前没有const修饰的前提下，传入指针是没法正常工作的，因为go支持修改数组元素）

### 2.5. map？

```C++
struct map_struct { // level 1
   int size;
   T* hash_bucket; // hash_bucket指向level2
};

struct map { // level 0
  map_struct* map_impl;
};
```

map=0级别复制

### 2.6. 总结

其实所有的赋值或者传参场景下，都会发生0级别内存的复制（复制意味着值语义），因为底层就是MOV，必然复制一块内存，其他级别的内存是否发生复制完全看语言的设计者。

比较特别的是C++的引用，这其实就是一个语法糖，T&的背后站着T*。
